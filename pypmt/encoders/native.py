from typing import Any, DefaultDict, Dict, List
import networkx as nx
import z3

from copy import deepcopy
from collections import defaultdict

from unified_planning.shortcuts import Effect, EffectKind
from unified_planning.shortcuts import FNode, Fraction
from unified_planning.model.fluent import get_all_fluent_exp

from unified_planning.plans import SequentialPlan
from unified_planning.plans import ActionInstance

from pypmt.encoders.basic import EncoderGrounded
from pypmt.encoders.utilities import str_repr, flatten_list
from pypmt.modifiers.base import Modifier
from pypmt.modifiers.modifierLinear import LinearModifier
from pypmt.modifiers.modifierParallel import ParallelModifier, MutexSemantics

from pypmt.planner.plan.smt_sequential_plan import SMTSequentialPlan

class EncoderGroundedNative(EncoderGrounded):
    """!
    As its filename implies, it inherits from the EncoderGrounded class. This is
    an adaptation of the original simple grounded encoding to work with the 
    native implementation of the planner.
    """
    
    def __init__(self, encoding_name, task, modifier, parallel):
        super().__init__(encoding_name, task, modifier, parallel)
        self.var_metadata: DefaultDict[str, Dict[str, str]] = defaultdict()

    def get_action_var(self, name, t):
        """!
        Given a str representation of a fluent/action and a timestep,
        returns the respective Z3 var.

        @param name: str representation of a fluent or action
        @param t: the timestep we are interested in
        @returns: the corresponding Z3 variable
        """
        return self.up_actions_to_z3[name][t]

    def _populate_modifiers(self):
        """!
        Populates an index on which grounded actions can modify which fluents.
        These are used afterwards for encoding the frame.
        """
        for action in self.task.actions:
            str_action = str_repr(action)
            for effect in action.effects:
               var_modified = str_repr(effect.fluent)
               condition = effect.condition # get the condition of the effect
               if effect.value.is_true(): # boolean effect
                   self.frame_add[var_modified].append((condition,str_action))
               elif effect.value.is_false():
                   self.frame_del[var_modified].append((condition, str_action))
               else: # is a numeric or complex expression
                   self.frame_num[var_modified].append((condition, str_action))

    def extract_plan(self, model, horizon):
        """!
        Given a model of the encoding generated by this class and its horizon,
        extract a plan from it.
        @returns: an instance of a SMTSequentialPlan
        """
        plan = SequentialPlan([])
        if not model: return SMTSequentialPlan(plan, self.task)
        if self.parallel:
            # Linearise plan taking into account step order
            action_map = {action.name: action for action in self}
            for t in range(0, horizon + 1):
                active_actions = set()
                for action in self:
                    if z3.is_true(model[self.up_actions_to_z3[action.name][t]]):
                        active_actions.add(action.name)
                if len(self.modifier.graph.nodes) > 0:  # type: ignore
                    sorted_action_names = list(nx.topological_sort(self.modifier.graph.subgraph(active_actions)))[::-1] # type: ignore
                else:
                    sorted_action_names = active_actions
                for action_name in sorted_action_names:
                    plan.actions.append(ActionInstance(action_map.get(action_name)))
        else:
            ## linearize partial-order plan
            for t in range(0, horizon + 1):
                for action in self:
                    if z3.is_true(model[self.up_actions_to_z3[action.name][t]]):
                        plan.actions.append(ActionInstance(action))
        return SMTSequentialPlan(plan, self.task)

    def encode(self, t):
        """!
        Builds and returns the formulas for a single transition step (from t to t+1).
        @param t: the current timestep we want the encoding for
        @returns: A dict with the different parts of the formula encoded
        """
        if t == 0:
            self.base_encode()
            return deepcopy(self.formula)

        self.create_variables(t+1) # we create another layer

        list_substitutions_actions = []
        list_substitutions_fluents = []
        for key in self.up_actions_to_z3.keys():
            list_substitutions_actions.append(
                (self.up_actions_to_z3[key][0],
                 self.up_actions_to_z3[key][t]))
        for key in self.up_fluent_to_z3.keys():
            list_substitutions_fluents.append(
                (self.up_fluent_to_z3[key][0],
                 self.up_fluent_to_z3[key][t]))
            list_substitutions_fluents.append(
                (self.up_fluent_to_z3[key][1],
                 self.up_fluent_to_z3[key][t + 1]))
 
        encoded_formula = dict()
        encoded_formula['initial'] = self.formula['initial']
        encoded_formula['goal']    = z3.substitute(self.formula['goal'], list_substitutions_fluents)
        encoded_formula['actions'] = z3.substitute(self.formula['actions'], list_substitutions_fluents + list_substitutions_actions)
        encoded_formula['frame']   = z3.substitute(self.formula['frame'], list_substitutions_fluents + list_substitutions_actions)
        if 'sem' in self.formula.keys():
            encoded_formula['sem'] = z3.substitute(self.formula['sem'], list_substitutions_actions)
        return encoded_formula

    def base_encode(self):
        """!
        Builds the encoding. Populates the formula dictionary class attribute,
        where all the "raw" formulas are stored. Those will later be used by 
        the encode function.
        """
        # create vars for first transition
        self.create_variables(0)
        self.create_variables(1)
        self._populate_modifiers() # do indices

        self.formula['initial'] = z3.And(self.encode_initial_state())  # Encode initial state axioms
        self.formula['goal']    = z3.And(self.encode_goal_state(0))  # Encode goal state axioms
        self.formula['actions'] = z3.And(self.encode_actions(0))  # Encode universal axioms
        self.formula['frame']   = z3.And(self.encode_frame(0))  # Encode explanatory frame axioms
        execution_semantics = self.encode_execution_semantics()
        if len(execution_semantics) > 0:
            self.formula['sem'] = z3.And(execution_semantics)  # Encode execution semantics (lin/par)


    def encode_variables_native(self) -> DefaultDict[str, Dict[str, str]]:
        """!
        Returns the variables created during the encoding process.
        The attributes that we could consider for variables are:
            - name: the id of the variable (maybe the declr and then we parse it back?)
            - type: the type of the variable (maybe included in the declr?)
            - static: a categorisation of the variable (either fixed or time-based)
            - kind: either state or action variable

        @returns: A dictionary with the variables created during the encoding process
        """
        # create vars for first transition so we can encode the problem using Z3py
        self.create_variables(0)
        self.create_variables(1)
        
        # now add the actions and fluent vars to the metadata, so we can move
        # that to the native planner
        for key in self.up_actions_to_z3.keys():
            self.var_metadata[key] = {
                "kind": "action",
                "sort": str(self.up_actions_to_z3[key][0].sort())
            }

        for key in self.up_fluent_to_z3.keys():
            self.var_metadata[key] = {
                "kind": "fluent",
                "sort": str(self.up_fluent_to_z3[key][0].sort())
            }
        return self.var_metadata

    def encode_formulas_native(self) -> Dict[str, str]:
        """!
        Builds the encoding for the native planner as a string representation.
        
        The attributes we could consider for the constraints are:
            - sexpr: the string representation of the constraint
            - type: initial, goal, transition function (actions), frame axiom,
                     execution semantics, state constraints 
        """
        assert len(self.var_metadata) > 0, "No variables created yet. Call encode_variables_native() first."
        self._populate_modifiers() # do indices
        formula: Dict[str, str] = {
        'initial' : z3.And(self.encode_initial_state()).sexpr(),  # type: ignore
        'goal'    : z3.And(self.encode_goal_state(0)).sexpr(),  # type: ignore
        'actions' : z3.And(self.encode_actions(0)).sexpr(),   # type: ignore
        'frame'   : z3.And(self.encode_frame(0)).sexpr() # type: ignore
        }  
        # Encode execution semantics (lin/par)
        execution_semantics = self.encode_execution_semantics()
        if execution_semantics:
            formula['sem'] = z3.And(execution_semantics).sexpr()   # type: ignore

        return formula

    def create_variables(self, t):
        """!
        Creates state variables needed in the encoding for step t.

        @param t: the timestep
        """
        # increment the formula length
        self.formula_length += 1

        # for actions
        for grounded_action in self.task.actions:
            key   = str_repr(grounded_action)
            keyt  = str_repr(grounded_action, t)
            act_var = z3.Bool(keyt, ctx=self.ctx)
            # record metadata
            self.var_metadata[key] = {
                "kind": "action",
                "sort": str(act_var.sort())
            }
            # add to the up <-> z3 mapping
            self.up_actions_to_z3[key].append(act_var)
            self.z3_actions_to_up[act_var] = key

        # for fluents
        for fe in self.all_fluents:
            key  = str_repr(fe)
            keyt = str_repr(fe, t)
            fluent_var = None
            if fe.type.is_real_type():
                fluent_var = z3.Real(keyt, ctx=self.ctx)
            elif fe.type.is_bool_type():
                fluent_var = z3.Bool(keyt, ctx=self.ctx)
            else:
                raise TypeError
            # add to the up <-> z3 mapping
            self.up_fluent_to_z3[key].append(fluent_var)
            # record metadata
            if t ==0:
                self.var_metadata[key] = {
                    "kind": "fluent",
                    "sort": str(fluent_var.sort())
                }

    def _expr_to_z3(self, expr, t, c=None):
        """!
        Traverses a UP AST in in-order and converts it to a Z3 expression.
        @param expr: The tree expression node. (Can be a value, variable name, or operator)
        @param t: The timestep for the Fluents to be considered 
        @param c: The context, which can be used to take into account free params
        @returns: An equivalent Z3 expression
        """
        if isinstance(expr, int): # A python Integer
            return z3.IntVal(expr, ctx=self.ctx)
        elif isinstance(expr, bool): # A python Boolean
            return z3.BoolVal(expr, ctx=self.ctx)
        elif isinstance(expr, float): 
            return z3.RealVal(expr, ctx=self.ctx)

        elif isinstance(expr, Effect): # A UP Effect
            eff = None
            if expr.kind == EffectKind.ASSIGN:
                eff = self._expr_to_z3(expr.fluent, t + 1, c) == self._expr_to_z3(expr.value, t, c)
            if expr.kind == EffectKind.DECREASE:
                eff = self._expr_to_z3(expr.fluent, t + 1, c) == self._expr_to_z3(expr.fluent, t, c) - self._expr_to_z3(expr.value, t, c)
            if expr.kind == EffectKind.INCREASE:
                eff = self._expr_to_z3(expr.fluent, t + 1, c) == self._expr_to_z3(expr.fluent, t, c) + self._expr_to_z3(expr.value, t, c)
            if expr.is_conditional():
                return z3.Implies(self._expr_to_z3(expr.condition, t, c) , eff, ctx=self.ctx)
            else:
                return eff

        elif isinstance(expr, FNode): # A UP FNode ( can be anything really )
            if expr.is_object_exp(): # A UP object
                raise ValueError(f"{expr} should not be evaluated")
            elif expr.is_constant(): # A UP constant
                return expr.constant_value()
            elif expr.is_or():  # A UP or
                return z3.Or([self._expr_to_z3(x, t, c) for x in expr.args])
            elif expr.is_and():  # A UP and
                return z3.And([self._expr_to_z3(x, t, c) for x in expr.args])
            elif expr.is_fluent_exp(): # A UP fluent
                return self.up_fluent_to_z3[str_repr(expr)][t]
            elif expr.is_parameter_exp():
                raise ValueError(f"{expr} should not be evaluated")
            elif expr.is_lt():
                return self._expr_to_z3(expr.args[0], t, c) < self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_le():
                return self._expr_to_z3(expr.args[0], t, c) <= self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_times():
                return self._expr_to_z3(expr.args[0], t, c) * self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_div():
                return self._expr_to_z3(expr.args[0], t, c) / self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_plus():
                return z3.Sum([self._expr_to_z3(x, t, c) for x in expr.args])
            elif expr.is_minus():
                return self._expr_to_z3(expr.args[0], t, c) - self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_not():
                return z3.Not(self._expr_to_z3(expr.args[0], t, c))
            elif expr.is_equals():
                return self._expr_to_z3(expr.args[0], t, c) == self._expr_to_z3(expr.args[1], t, c)
            elif expr.is_implies():
                return z3.Implies(self._expr_to_z3(expr.args[0], t, c), self._expr_to_z3(expr.args[1], t, c))
            else:
                raise TypeError(f"Unsupported expression: {expr} of type {type(expr)}")
        elif isinstance(expr, Fraction):
            return z3.RealVal(f"{expr.numerator}/{expr.denominator}", ctx=self.ctx)
        else:
            raise TypeError(f"Unsupported expression: {expr} of type {type(expr)}")

class EncoderSequentialNative(EncoderGroundedNative):
    """
    Implementation of the classical sequential encoding of Kautz & Selman 1992
    where each timestep can have exactly one action.
    """
    def __init__(self, task):
        super().__init__("seq", task, LinearModifier(), parallel=False)

class EncoderForallNative(EncoderGroundedNative):
    """
    Forall-step encoding, allowing parallelisation in a real-world manner by permitting multiple
    actions per step.
    """
    def __init__(self, task):
        super().__init__("parForall", task, 
                         ParallelModifier(MutexSemantics.FORALL, lazy=False), parallel=True)

class EncoderExistsNative(EncoderGroundedNative):
    """
    Exists-step encoding allowing a more relaxed parallelisation than forall.
    """
    def __init__(self, task):
        super().__init__("parExists", task, 
                         ParallelModifier(MutexSemantics.EXISTS, lazy=False), parallel=True)

class EncoderForallLazyNative(EncoderGroundedNative):
    """
    Lazy Forall-step encoding, initially adds no interference mutexes and determines
    when to add them lazily
    """
    def __init__(self, task):
        super().__init__("parLazyForall", task, 
                         ParallelModifier(MutexSemantics.FORALL, lazy=True), parallel=True)

class EncoderExistsLazyNative(EncoderGroundedNative):
    """
    Lazy Exists-step encoding, initially adds no interference mutexes and determines
    when to add them lazily
    """
    def __init__(self, task):
        super().__init__("parLazyExists", task,
                         ParallelModifier(MutexSemantics.EXISTS, lazy=True), parallel=True)
